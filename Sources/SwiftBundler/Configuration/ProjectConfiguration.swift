import Foundation
import Parsing
import Version
import ErrorKit

@Configuration(overlayable: true)
struct ProjectConfiguration: Codable {
  /// The name of the default project generated by Swift Bundler.
  static let rootProjectName = "root"

  @ExcludeFromFlat
  var source: Source

  @ExcludeFromFlat
  var revision: String?

  @Validate({ (builder: Builder) throws(ConfigurationFlattener.Error) in
    guard builder.name.hasSuffix(".swift") else {
      throw RichError(cause: Error(.projectBuilderNotASwiftFile(builder.name)))
    }
  })
  var builder: Builder

  @ExcludeFromOverlay
  var products: [String: Product]

  @Aggregate("source")
  func flattenSource(with context: ConfigurationFlattener.Context)
    throws(ConfigurationFlattener.Error) -> Source.Flat
  {
    return try source.flatten(
      withRevision: revision,
      revisionField: context.codingPath.appendingKey(ProjectConfiguration.CodingKeys.revision)
    )
  }

  @Configuration(overlayable: false)
  struct Builder: Codable {
    var name: String
    var type: BuilderType
    @ExcludeFromFlat
    var apiSource: Source?
    @ExcludeFromFlat
    var api: APIRequirement?

    enum BuilderType: String, Codable, TriviallyFlattenable {
      case wholeProject
    }

    @Aggregate("api")
    func flattenAPI(with context: ConfigurationFlattener.Context)
      throws(ConfigurationFlattener.Error) -> ProjectConfiguration.Source.FlatWithDefaultRepository
    {
      try ConfigurationFlattener.Error.catch {
        try apiSource.flatten(
          withRequirement: self.api,
          requirementField: context.codingPath.appendingKey(CodingKeys.api)
        )
      }
    }
  }

  enum Source {
    case git(URL)
    case local(String)

    enum Flat {
      case local(_ path: String)
      case git(URL, requirement: APIRequirement)
    }

    /// A flattened version of source for usecases where there's a sensible
    /// default git repository (e.g. the stackotter/swift-bundler repository
    /// is the default if no builder API source is explicitly provided).
    enum FlatWithDefaultRepository {
      case local(_ path: String)
      case git(URL?, requirement: APIRequirement)

      func normalized(usingDefault defaultGitURL: URL) -> Flat {
        switch self {
          case .local(let path):
            return .local(path)
          case .git(let url, let requirement):
            return .git(url ?? defaultGitURL, requirement: requirement)
        }
      }
    }

    func flatten(
      withRevision revision: String?,
      revisionField: CodingPath
    ) throws(ConfigurationFlattener.Error) -> Flat {
      switch self {
        case .git(let url):
          guard let revision else {
            let message = ConfigurationFlattener.ErrorMessage.gitSourceMissingAPIRequirement(
              url,
              field: revisionField
            )
            throw ConfigurationFlattener.Error(message)
          }
          return .git(url, requirement: .revision(revision))
        case .local(let path):
          return .local(path)
      }
    }
  }

  enum APIRequirement {
    case revision(String)
  }

  @Configuration(overlayable: true)
  struct Product: Codable {
    var type: ProductType
    var outputDirectory: String?

    enum ProductType: String, Codable, TriviallyFlattenable {
      case dynamicLibrary
      case staticLibrary
      case executable
    }
  }
}

extension ProjectConfiguration.Source: Codable {
  init(from decoder: any Decoder) throws {
    let container = try decoder.singleValueContainer()
    let value = try container.decode(String.self)
    let parser = OneOf {
      Parse {
        "git("
        PrefixUpTo(")")
        ")"
      }
      .map { (url: Substring) -> Result<Self, ProjectConfiguration.Error> in
        guard let url = URL(string: String(url)) else {
          return .failure(ProjectConfiguration.Error(.invalidGitURL(String(url))))
        }
        return .success(Self.git(url))
      }

      Parse {
        "local("
        PrefixUpTo(")")
        ")"
      }.map { path in
        Result<_, ProjectConfiguration.Error>.success(Self.local(String(path)))
      }
    }
    self = try parser.parse(value).get()
  }

  func encode(to encoder: any Encoder) throws {
    let value: String
    switch self {
      case .git(let url):
        value = "git(\(url.absoluteString))"
      case .local(let path):
        value = "local(\(path))"
    }
    var container = encoder.singleValueContainer()
    try container.encode(value)
  }
}

extension ProjectConfiguration.APIRequirement: Codable {
  init(from decoder: any Decoder) throws {
    let container = try decoder.singleValueContainer()
    let value = try container.decode(String.self)
    let parser = OneOf {
      Parse {
        "revision("
        PrefixUpTo(")")
        ")"
      }.map { revision in
        Self.revision(String(revision))
      }
    }
    self = try parser.parse(value)
  }

  func encode(to encoder: any Encoder) throws {
    let value: String
    switch self {
      case .revision(let revision):
        value = "revision(\(revision))"
    }
    var container = encoder.singleValueContainer()
    try container.encode(value)
  }
}

extension ProjectConfiguration.Source? {
  func flatten(
    withRequirement requirement: ProjectConfiguration.APIRequirement?,
    requirementField: CodingPath
  ) throws(ConfigurationFlattener.Error)
    -> ProjectConfiguration.Source.FlatWithDefaultRepository
  {
    switch self {
      case .local(let path):
        guard requirement == nil else {
          throw ConfigurationFlattener.Error(.localSourceMustNotSpecifyRevision(path))
        }
        return .local(path)
      case .git(let url):
        guard let apiRequirement = requirement else {
          throw ConfigurationFlattener.Error(
            .gitSourceMissingAPIRequirement(url, field: requirementField)
          )
        }
        return .git(url, requirement: apiRequirement)
      case nil:
        guard let apiRequirement = requirement else {
          throw ConfigurationFlattener.Error(.defaultSourceMissingAPIRequirement)
        }
        return .git(nil, requirement: apiRequirement)
    }
  }
}

extension ProjectConfiguration.Product.Flat {
  private func baseArtifactPath(whenNamed name: String, platform: Platform) -> String {
    let baseName: String
    switch type {
      case .dynamicLibrary, .staticLibrary:
        switch platform.partitioned {
          case .linux, .apple:
            baseName = "lib\(name)"
          case .windows:
            baseName = name
        }
      case .executable:
        baseName = name
    }

    if let outputDirectory = outputDirectory {
      return "\(outputDirectory)/\(baseName)"
    } else {
      return baseName
    }
  }

  func artifactPath(whenNamed name: String, platform: Platform) -> String {
    // We include the `.` in the extension so that we can use "" to signify
    // no extension without any special case logic.
    let fileExtension: String
    switch type {
      case .dynamicLibrary:
        switch platform.partitioned {
          case .linux:
            fileExtension = ".so"
          case .windows:
            fileExtension = ".dll"
          case .apple:
            fileExtension = ".dylib"
        }
      case .staticLibrary:
        // TODO: Support static libraries on Windows
        fileExtension = ".a"
      case .executable:
        switch platform.partitioned {
          case .windows:
            fileExtension = ".exe"
          case .linux, .apple:
            fileExtension = ""
        }
    }

    let basePath = baseArtifactPath(whenNamed: name, platform: platform)
    return "\(basePath)\(fileExtension)"
  }

  func auxiliaryArtifactPaths(whenNamed name: String, platform: Platform) -> [String] {
    let fileExtensions: [String]
    switch platform.partitioned {
      case .windows:
        if type == .dynamicLibrary {
          fileExtensions = ["lib", "pdb"]
        } else {
          return []
        }
      case .linux, .apple:
        return []
    }

    let basePath = baseArtifactPath(whenNamed: name, platform: platform)
    return fileExtensions.map { "\(basePath).\($0)" }
  }
}
