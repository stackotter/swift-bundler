import Foundation
import Parsing
import Version

struct ProjectConfiguration: Codable {
  /// The name of the default project generated by Swift Bundler.
  static let rootProjectName = "root"

  enum Error: LocalizedError {
    case invalidGitURL(String)
    case gitSourceMissingRevision(URL, field: CodingPath)
    case localSourceMustNotSpecifyRevision(_ path: String)
    case gitSourceMissingAPIRequirement(_ url: URL)
    case defaultSourceMissingAPIRequirement

    var errorDescription: String? {
      switch self {
        case .invalidGitURL(let url):
          return "'\(url)' is not a valid URL"
        case .gitSourceMissingRevision(let gitURL, let field):
          return
            """
            Git source '\(gitURL.absoluteString)' requires a revision. Provide
            the '\(field)' field.
            """
        case .localSourceMustNotSpecifyRevision(let path):
          return "'api' field is redundant when local builder API is used ('local(\(path))')"
        case .gitSourceMissingAPIRequirement:
          return "Builder API sourced from git missing API requirement (provide the 'api' field)"
        case .defaultSourceMissingAPIRequirement:
          return "Default Builder API missing API requirement (provide the 'api' field)"
      }
    }
  }

  var source: Source
  var revision: String?
  var builder: Builder
  var products: [String: Product]

  /// Conditionally applied configuration overlays.
  var overlays: [Overlay]?

  enum CodingKeys: String, CodingKey {
    case source
    case revision
    case builder
    case products
    case overlays
  }

  struct Overlay: Codable, ConfigurationOverlay {
    typealias Base = ProjectConfiguration

    static let exclusiveProperties: [OverlayCondition: PropertySet<Self>] = [:]

    var condition: OverlayCondition
    var source: Source?
    var revision: String?
    var builder: Builder?

    enum CodingKeys: String, CodingKey {
      case condition
      case source
      case revision
      case builder
    }

    func merge(into base: inout Base) {
      Self.merge(&base.source, source)
      Self.merge(&base.revision, revision)
      Self.merge(&base.builder, builder)
    }
  }

  struct Flat {
    var source: Source.Flat
    var builder: Builder.Flat
    var products: [String: Product.Flat]
  }

  struct Builder: Codable {
    var name: String
    var type: BuilderType
    var apiSource: Source?
    var api: APIRequirement?

    enum CodingKeys: String, CodingKey {
      case name
      case type
      case apiSource = "api_source"
      case api = "api"
    }

    struct Flat {
      var name: String
      var type: BuilderType
      var api: Source.FlatWithDefaultRepository
    }

    enum BuilderType: String, Codable {
      case wholeProject
    }

    func flatten(at codingPath: CodingPath) -> Result<Flat, Error> {
      return apiSource.flatten(
        withRequirement: api,
        requirementField: codingPath.appendingKey(CodingKeys.api)
      ).map { api in
        Flat(name: name, type: type, api: api)
      }
    }
  }

  enum Source {
    case git(URL)
    case local(String)

    enum Flat {
      case local(_ path: String)
      case git(URL, requirement: APIRequirement)
    }

    /// A flattened version of source for usecases where there's a sensible
    /// default git repository (e.g. the stackotter/swift-bundler repository
    /// is the default if no builder API source is explicitly provided).
    enum FlatWithDefaultRepository {
      case local(_ path: String)
      case git(URL?, requirement: APIRequirement)

      func normalized(usingDefault defaultGitURL: URL) -> Flat {
        switch self {
          case .local(let path):
            return .local(path)
          case .git(let url, let requirement):
            return .git(url ?? defaultGitURL, requirement: requirement)
        }
      }
    }

    func flatten(
      withRevision revision: String?,
      revisionField: CodingPath
    ) -> Result<Flat, Error> {
      switch self {
        case .git(let url):
          guard let revision = revision else {
            let error = Error.gitSourceMissingRevision(
              url,
              field: revisionField
            )
            return .failure(error)
          }
          return .success(.git(url, requirement: .revision(revision)))
        case .local(let path):
          return .success(.local(path))
      }
    }
  }

  enum APIRequirement {
    case revision(String)
  }

  struct Product: Codable {
    var type: ProductType
    var outputDirectory: String?

    var overlays: [Overlay]

    enum CodingKeys: String, CodingKey {
      case type
      case outputDirectory = "output_directory"
      case overlays
    }

    enum ProductType: String, Codable {
      case dynamicLibrary
      case staticLibrary
      case executable
    }

    struct Flat {
      var type: ProductType
      var outputDirectory: String?
    }

    func flatten() -> Flat {
      Flat(type: type, outputDirectory: outputDirectory)
    }

    struct Overlay: ConfigurationOverlay, Codable {
      typealias Base = Product.Flat

      var condition: OverlayCondition
      var type: ProductType?
      var outputDirectory: String?

      enum CodingKeys: String, CodingKey {
        case condition
        case type
        case outputDirectory = "output_directory"
      }

      func merge(into base: inout Product.Flat) {
        Self.merge(&base.type, type)
        Self.merge(&base.outputDirectory, outputDirectory)
      }
    }
  }
}

extension ProjectConfiguration.Source: Codable {
  init(from decoder: any Decoder) throws {
    let container = try decoder.singleValueContainer()
    let value = try container.decode(String.self)
    let parser = OneOf {
      Parse {
        "git("
        PrefixUpTo(")")
        ")"
      }
      .map { (url: Substring) -> Result<Self, ProjectConfiguration.Error> in
        guard let url = URL(string: String(url)) else {
          return .failure(ProjectConfiguration.Error.invalidGitURL(String(url)))
        }
        return .success(Self.git(url))
      }

      Parse {
        "local("
        PrefixUpTo(")")
        ")"
      }.map { path in
        Result<_, ProjectConfiguration.Error>.success(Self.local(String(path)))
      }
    }
    self = try parser.parse(value).unwrap()
  }

  func encode(to encoder: any Encoder) throws {
    let value: String
    switch self {
      case .git(let url):
        value = "git(\(url.absoluteString))"
      case .local(let path):
        value = "local(\(path))"
    }
    var container = encoder.singleValueContainer()
    try container.encode(value)
  }
}

extension ProjectConfiguration.APIRequirement: Codable {
  init(from decoder: any Decoder) throws {
    let container = try decoder.singleValueContainer()
    let value = try container.decode(String.self)
    let parser = OneOf {
      Parse {
        "revision("
        PrefixUpTo(")")
        ")"
      }.map { revision in
        Self.revision(String(revision))
      }
    }
    self = try parser.parse(value)
  }

  func encode(to encoder: any Encoder) throws {
    let value: String
    switch self {
      case .revision(let revision):
        value = "revision(\(revision))"
    }
    var container = encoder.singleValueContainer()
    try container.encode(value)
  }
}

extension ProjectConfiguration.Source? {
  func flatten(
    withRequirement requirement: ProjectConfiguration.APIRequirement?,
    requirementField: CodingPath
  ) -> Result<
    ProjectConfiguration.Source.FlatWithDefaultRepository,
    ProjectConfiguration.Error
  > {
    switch self {
      case .local(let path):
        guard requirement == nil else {
          return .failure(
            ProjectConfiguration.Error.localSourceMustNotSpecifyRevision(path)
          )
        }
        return .success(.local(path))
      case .git(let url):
        guard let apiRequirement = requirement else {
          return .failure(
            ProjectConfiguration.Error.gitSourceMissingAPIRequirement(url)
          )
        }
        return .success(.git(url, requirement: apiRequirement))
      case nil:
        guard let apiRequirement = requirement else {
          return .failure(
            ProjectConfiguration.Error.defaultSourceMissingAPIRequirement
          )
        }
        return .success(.git(nil, requirement: apiRequirement))
    }
  }
}

extension ProjectConfiguration.Product.Flat {
  private func baseArtifactPath(whenNamed name: String, platform: Platform) -> String {
    let baseName: String
    switch type {
      case .dynamicLibrary, .staticLibrary:
        switch platform {
          case .linux, .macOS, .iOS, .iOSSimulator,
            .tvOS, .tvOSSimulator,
            .visionOS, .visionOSSimulator:
            baseName = "lib\(name)"
          case .windows:
            baseName = name
        }
      case .executable:
        baseName = name
    }

    if let outputDirectory = outputDirectory {
      return "\(outputDirectory)/\(baseName)"
    } else {
      return baseName
    }
  }

  func artifactPath(whenNamed name: String, platform: Platform) -> String {
    // We include the `.` in the extension so that we can use "" to signify
    // no extension without any special case logic.
    let fileExtension: String
    switch type {
      case .dynamicLibrary:
        switch platform {
          case .linux:
            fileExtension = ".so"
          case .windows:
            fileExtension = ".dll"
          case .macOS, .iOS, .iOSSimulator,
            .tvOS, .tvOSSimulator,
            .visionOS, .visionOSSimulator:
            fileExtension = ".dylib"
        }
      case .staticLibrary:
        // TODO: Support static libraries on Windows
        fileExtension = ".a"
      case .executable:
        fileExtension = ""
    }

    let basePath = baseArtifactPath(whenNamed: name, platform: platform)
    return "\(basePath)\(fileExtension)"
  }

  func auxiliaryArtifactPaths(whenNamed name: String, platform: Platform) -> [String] {
    let fileExtensions: [String]
    switch platform {
      case .windows:
        if type == .dynamicLibrary {
          fileExtensions = ["lib", "pdb"]
        } else {
          return []
        }
      case .linux, .macOS, .iOS, .iOSSimulator,
        .tvOS, .tvOSSimulator, .visionOS, .visionOSSimulator:
        return []
    }

    let basePath = baseArtifactPath(whenNamed: name, platform: platform)
    return fileExtensions.map { "\(basePath).\($0)" }
  }
}
